
Java内存结构：
堆---内存中最大的一块，被所有线程共享的一块内存区域，所有对象的实例以及数组都要在堆上分配-----调优都在此处
方法区：存储已被虚拟机加载的类信息、常量、静态变量----永久数据----线程共享
        常量信息当class文件被加载的时候，就会被初始化，一般不定义太多常量，因为不会被回收，耗内存
java栈：基本数据类型，局部变量，代码运行完毕，自动释放内存-------线程不共享，每个线程独立出来了
本地方法栈：和C语言打交道的，native修饰，和JNI打交道
常量池：属于方法区的一部分，放类信息的某些信息
程序计数器：代码执行到哪一行了

方法存在哪里？----栈中？？？？
------------------------------
什么是垃圾回收机制？
jvm不定时的回收不可达对象，不可达对象就是对象没有被引用

System.gc()//提示给gc进行垃圾回收，不代表立即进行回收，JVM有空才回收，
JVM有gc线程，gc线程不定时回收垃圾，gc线程是守护线程，主线程挂了，gc线程就要挂
finalize()方法：垃圾回收机制之前会进行执行的方法

--------------------
堆内存的划分：
新生代：eden s0区 s1区   其中s0和s1大小相等，做复制交换使用
老年代
默认老年代空间是新生代的2倍------1:2=新生代：老年代
新生代：刚出生不久的对象，存放在新生代里面，存放不是经常使用的对象
老年代：存放比较活跃的对象，存放经常被引用的对象----貌似被引用15次后，就从新生代放入到老年代
垃圾回收机制回收在新生代比较频繁，，老年代回收次数比较少

-----------------------------------------------
垃圾回收机制如何判断对象是存活的？
1.引用计数法：  被淘汰了，有缺点，如果A引用B，B引用A，引用计数法无法判断对象是否该回收
默认年龄0岁，每个对象有一个年龄，如果小于等于15岁，存放在新生代，如若大于15岁就会存放到老年代
GC线程不定时进行垃圾回收时，如果对象被引用的话，年龄加1，如果对象没有被引用，年龄减1
如果年龄为0岁的话，垃圾回收机制认为不可达对象，会被清理
2.可达性算法：GC Roots
判断是否可达：需要和根节点有依赖关系，如果没有和GC Roots有任何引用 的情况下，这时候GC认为就是不可达对象
GC Roots从方法区和虚拟机栈，本地方法栈中来，只要方法区和虚拟机栈，本地方法栈中变量有和堆的对象有关联，证明就是可达

----------------------------------------------
垃圾回收机制算法

1.标记清除算法：0标记为存活，1标记为没有存活，标记为1的对象全部回收
垃圾回收机制遍历堆内存中标识为不可达对象进行清理
缺点：产生碎片化，因为不够连贯，貌似一个一个删除，效率不高，删不干净
可达和不可达全部混合在一起，删除不可达对象后，内存不连续了
应用场景：老年代

2.复制算法
主要是新生来中s0和s1区，s0和s1有一个一定为空，目的是为了存放下一次复制，
s0区有不可达和可达对象，将可达对象复制到s1区，然后将整个s0区给清理掉，现在s0区为空了
下一次垃圾回收的时候
s1区有不可达和可达对象，将可达对象复制到s0区，然后将整个s1区给清理掉，现在s1区为空了
优点：解决了碎片化的问题，速度快，清理干净
缺点：浪费空间
应用场景：新生代
总结：GC回收将可达对象复制到下一个区域，然后直接清理当前区域
如果对象在s0和s1存在了15次后，对象会移入到老年代里面

3.标记整理算法
解决标记清除算法碎片化问题，将可达对象放在一起


-----------------------------------JVM参数调优-------------------------------------------------
尽量减少常量信息
尽量减少垃圾回收的次数
新生代回收次数比老年代多

1.堆初始值与堆内存最大值一定保持一致
    原因：减少垃圾回收机制次数
初始值越小，垃圾回收机制次数越多
2.新生代与老年代配置成1:3或者1:4，让新生代回收次数比老年代多


-XX:+PrintGC      每次触发GC的时候打印相关日志
-XX:+UseSerialGC      串行回收
-XX:+PrintGCDetails  更详细的GC日志
-Xms               堆初始值
-Xmx               堆最大可用值
-Xmn               新生代堆最大可用值
-XX:SurvivorRatio     用来设置新生代中eden空间和from/to空间的比例.
含以-XX:SurvivorRatio=eden/from=den/to
总结:在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等，
这样的好处是可以减少程序运行时垃圾回收次数，从而提高效率。
-XX:SurvivorRatio     用来设置新生代中eden空间和from/to空间的比例.
-XX:NewRatio  老年代与新生代的比例

配置JVM参数
参数: -Xms5m -Xmx20m -XX:+PrintGCDetails -XX:+UseSerialGC -XX:+PrintCommandLineFlags


------------------------------------串行并行垃圾收集器-----------------------------------------------
串行垃圾收集器：单线程收集垃圾，效率低，回收期间会暂停所有应用线程的执行---默认的
并行垃圾收集器：多线程垃圾回收，效率高------电脑核数*2就是配置的线程数
用法：配置参数就行了

调优：肯定用并行垃圾收集器
并行垃圾收集器，吞吐量并串行垃圾回收器的吞吐量更多
吞吐量：1s内请求的次数