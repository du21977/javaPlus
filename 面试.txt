
面试题：
------------------------------多线程相关--------------------------------
1.多线程安全问题
多线程共享全局变量，做写操作时，会有线程安全问题
2.lock与synchronized区别
自动挡和手动挡
synchronized(关键字)什么时候释放锁--1.代码块执行完----2,代码中出现异常
lock(接口)什么时候释放锁------手动主动释放锁  -----性能比synchronized性能稍微好
ReentrantLock--可重入锁---可以解决死锁问题----可设置超时自动释放锁
3.线程池
4.线程间通讯
    wait  / notify / notifyAll
5.ThreadLocal
每个线程都有自己的局部变量，而不让线程出现线程安全问题
6.volatile
线程可见和禁止重排序
6.1. volatile和synchronized的区别
synchronized：原子性、互斥性、可见性
volatile ：可见性、禁止重排序----复合操作不能保证原子性，就是多个线程可同时操作
volatile修饰变量，synchronized修饰代码块和方法
使用场景：volatile----单个线程操作变量，然后while循环判断该变量的改变
            synchronized---高并发，多个线程同时操作共享变量
  volatile不能保证原子性，AutomicIntreager能修饰变量保证原子性
6.2. JMM -JAVA Memory Model java内存模型
    并发编程中如何处理可见性、原子性、有序性的问题
    java内存模型:共享变量在主内存中，各个线程共享变量时，会从主内存中复制一份到线程自己的工作内存中，
    线程修改本地内存变量后，什么时候同步到主内存是不知道的，其他线程什么时候从主内存同步修改后的变量值也是不知道的，
    这就导致了线程同步问题了，synchronized就来了，线程A释放锁后会将变量同步到主内存，线程B获取锁后会同步主内存的变量
    还有volatile,加了volatile后，主内存和工作内存也会立马同步(会发一些命令，让其同步)
7.java并发包
Lock、Exectors、ReentrantLock、Condition、ConcurrentHashMap、BlockQueue、AtomicInteager
8.多线程实际使用场景
主线程和gc线程，多线程下载图片
9.锁
分布式锁zookeeper
10如何控制线程执行的顺序
方法一：
用join方法来保证多线程的执行顺序
join:让主线程等待子线程执行完后才继续执行，就是让当前线程(主线程)等待
方法二：
ExecutorService exector = Excutors.newSingleThreadExector();
exector.submit(thread);
单线程执行，会将线程放入一个队列，FIFO先进先出

11.多线从创建方式
Thread
Runnable接口
Callable Future 带返回值的多线程操作
12.线程的生命周期
创建、就绪、运行、阻塞、终止


----------------------------消息中间件MQ相关------------------------------------
重试机制、日志补偿机制、幂等性问题


-----------------------------高并发解决方案------------------------------------
缓存：redis
数据库：读写分离、分库分表、SQL优化
服务器：负载均衡、CDN加速
JVM：并行垃圾回收、初始内存与最大内存设置成一致
代码层：算法优化

----------------------------------分布式缓存redis相关-------------------------------------------

-------------------------------------数据库相关---------------------------------------------------

---------------------------------------JVM相关-------------------------------------------------


--------------------------------------最大难题最大收获--------------------------------------------------------
我们项目现在采用目前流行的技术，微服务架构(把一个项目拆分成很多子项目，每个项目之间互不影响)，服务与服务之间采用
RPC通讯调用，对分布式各种常见问题解决方案，都很熟悉
项目中在订单调用支付模块时，可能会产生分布式事务-----解决方案--TCC---LCN
生成订单id时，在集群环境下，可能产生重复的id，这时就要用到分布式锁
分布式job，
对分布式微服务、高并发、高可用、性能优化，缓存、消息中间件，并发编程相对比较熟悉