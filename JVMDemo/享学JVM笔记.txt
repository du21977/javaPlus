

1.6运行时常量池在方法区
1.7运行时常量池在堆中
1.8没有了方法区了，搞出了一个元空间本地内存

在Java, 可作为GC Roots的对象包括:
1.方法区: 类静态属性引用的对象;
2.方法区: 常量引用的对象;
3.虚拟机栈(本地变量表)中引用的对象.
4.本地方法栈JNI(Native方法)中引用的对象

从GC roots都能到达的对象才不能被回收，有不能到达的对象就可被回收


---------------------------------------------------
强引用
软引用 SoftReference------OOM时会被回收--------GC时，不一定回收
弱引用 WeakReference------GC时会被回收
虚引用 PhantomReference---幽灵引用，最弱，被垃圾回收的时候收到通知而已，基本上用不着--，都拿不到对象的实例，太虚了


-----------------------
垃圾回收：内存够用就不会回收，除非我们手动调用system.gc()


根据统计，新生代90%以上的对象都是要被回收
新生代用复制垃圾回收算法
新生代是minor gc
老年代是full gc---

---------------------------------
新生代和老年代都有自己的垃圾收集器
串行和并行回收器

单CPU用串行垃圾收集器，最快，因为并行线程切换需要时间
多CPU用并行垃圾收集器，多个gc线程同时垃圾回收，效率高，用户线程暂停时间短

GC线程工作时，所有的用户线程都得暂停操作


------------------JVM执行子系统-------------------------------------
通过这个看class文件挺好
javap -verbose xxx.class

.class文件是8位字节二进制文件
运行时会转换成字节码指令执行

class文件中包含，java版本号，常量池、方法名集合等
常量池包含字面量和符号引用
字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。
而符号引用则属于编译原理方面的概念，包括了下面三类常量：
类和接口的全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符

cglib就是利用这种字节码技术实现的

--------------------------类加载机制------------------------------------------

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）
于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：
1）遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。
5）当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

注意：
对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。
常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值“hello world”存储到了NotInitialization类的常量池中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。
也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。

-----------------------------------------
JVM调优：
GC调优目的
GC的时间够小
GC的次数够少
发生Full GC的周期足够的长，时间合理，最好是不发生。

GC调优的最重要的三个选项：
第一位：选择合适的GC回收器
第二位：选择合适的堆大小
第三位：选择年轻代在堆中的比重