

1.6运行时常量池在方法区
1.7运行时常量池在堆中
1.8没有了方法区了，搞出了一个元空间本地内存

在Java, 可作为GC Roots的对象包括:
1.方法区: 类静态属性引用的对象;
2.方法区: 常量引用的对象;
3.虚拟机栈(本地变量表)中引用的对象.
4.本地方法栈JNI(Native方法)中引用的对象

从GC roots都能到达的对象才不能被回收，有不能到达的对象就可被回收


---------------------------------------------------
强引用
软引用 SoftReference------OOM时会被回收--------GC时，不一定回收
弱引用 WeakReference------GC时会被回收
虚引用 PhantomReference---幽灵引用，最弱，被垃圾回收的时候收到通知而已，基本上用不着--，都拿不到对象的实例，太虚了


-----------------------
垃圾回收：内存够用就不会回收，除非我们手动调用system.gc()


根据统计，新生代90%以上的对象都是要被回收
新生代用复制垃圾回收算法
新生代是minor gc
老年代是full gc---

---------------------------------
新生代和老年代都有自己的垃圾收集器
串行和并行回收器

单CPU用串行垃圾收集器，最快，因为并行线程切换需要时间
多CPU用并行垃圾收集器，多个gc线程同时垃圾回收，效率高，用户线程暂停时间短

GC线程工作时，所有的用户线程都得暂停操作


------------------JVM执行子系统-------------------------------------
通过这个看class文件挺好
javap -verbose xxx.class




